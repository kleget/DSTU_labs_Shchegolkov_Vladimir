# Лабораторная работа 7 — собственные компоненты и управление интерфейсом (Swing)

Код лабы: `sem3/Java/lab7`.  
Каждый `*.java`‑файл здесь — минимальный пример для конкретного задания.  
Запускать из каталога `sem3/Java`: `java lab7.ClassName` (предварительно: `javac lab7/*.java`).

Ниже подробно, но без «воды»: что делает каждая программа и как это объяснить, если вы знаете Python, но не Java.

---

## Задание 1 — Look and Feel + набор базовых компонентов

**Файл:** `Task1LookAndFeel.java`

**Что делает:**
- Создаёт окно (`JFrame`).
- В верхней панели (`JPanel`) размещены:
  - `JComboBox<UIManager.LookAndFeelInfo>` — список доступных в системе «Look & Feel» (оформление интерфейса);
  - обычная кнопка (`JButton`), чекбокс (`JCheckBox`), радио‑кнопка (`JRadioButton`) — просто чтобы видно было, как они выглядят в разных LAF.
- В центре окна — `JTable` с простыми данными о языках программирования: имя, автор, год.

**Как работает переключение LAF:**
- В конструкторе комбобокс заполняется значениями `UIManager.getInstalledLookAndFeels()`.
- На него навешан `ActionListener` (лямбда):
  - берём выбранный элемент как `UIManager.LookAndFeelInfo`;
  - вызываем `UIManager.setLookAndFeel(info.getClassName())`;
  - затем `SwingUtilities.updateComponentTreeUI(this)` — обновляет все компоненты внутри окна, чтобы применился новый стиль.
- Аналог в Python: смена темы/стиля в Qt + принудительное обновление виджетов.

---

## Задание 2 — панель управления для других задач

**Файл:** `Task2ControlPad.java`

**Что делает:**
- Окно делится на две части (`GridLayout(1, 2)`):
  - левая панель с заголовком «Рисунок»;
  - правая панель с заголовком «Фильтр».
- В каждой панели (`section()`):
  - метка «Слайдер» + реальное значение (`JLabel`);
  - `JSlider` (от 10 до 100) — при изменении обновляет метку с числом;
  - `JSpinner` (целое от 1 до 10) — может означать, например, число повторов/интенсивность;
  - кнопки «Старт» и «Стоп» (логика не реализована, это только UI).

**Зачем так:**
- Это «пульт управления» для других заданий (например, анимации или фильтров).
- В реальных задачах эти элементы могли бы управлять скоростью, количеством объектов, типом фильтра и т.п.
- Сейчас код оставлен максимально простым: без дополнительного состояния и обработчиков, кроме обновления текста у слайдера.

---

## Задание 3 — анимация шариков с управлением количеством

**Файл:** `Task3BallController.java`

**Основные классы:**
- `Task3BallController` — окно с:
  - панелью `BallPanel` (центр), где движутся шарики;
  - нижней панелью с контролами: `JSpinner` (максимум шариков), кнопка «Добавить», кнопка «Пауза/Старт», метка с текущим количеством.
- `BallPanel` — наследник `JPanel`, внутри:
  - список `List<Ball>` — каждый шарик имеет координаты `x, y`, скорости `dx, dy` и размер;
  - `Timer` (`javax.swing.Timer`) с периодом 16 мс (примерно 60 FPS);
  - флаг `run` (идёт ли анимация).

**Как работает анимация:**
- Таймер создаётся как `new Timer(16, e -> { if (run) move(); repaint(); })`.
  - при каждом тике, если `run == true`, вызывается `move()` и затем `repaint()`.
- В `move()`:
  - для каждого шарика добавляются скорости: `x += dx; y += dy;`;
  - если шарик вышел за границы панели, скорость по этой оси меняется на противоположную (`dx = -dx`, `dy = -dy`) — отражение от стенки.
- В `paintComponent(Graphics g)`:
  - вызывается `super.paintComponent(g)` (очистка фона);
  - для каждого `Ball` рисуется цветной круг (`g.fillOval(...)`).

**Как управляется количество шариков:**
- `JSpinner` задаёт максимум (`max`): `panel.setMax((int) max.getValue())`:
  - если шариков больше нового максимума — лишние удаляются из списка;
- Кнопка «Добавить» вызывает `panel.addBall()`:
  - если текущих шариков меньше максимума — создаётся новый шарик с рандомной позицией и скоростью.
- Кнопка «Пауза/Старт» переключает флаг `run` и меняет текст кнопки.

Аналог в Python: список объектов + `after(16, tick)`, где `tick` обновляет позиции и перерисовывает холст.

---

## Задание 4 — простейший графопостроитель с выбором функции и цвета

**Файл:** `Task4FunctionPlotter.java`

**Что есть в интерфейсе:**
- Поле «От» (`startField`) и «До» (`endField`) — границы интервала по X.
- `JComboBox<String>` с функциями:
  - `"sin(x)"`,
  - `"sin(x*x)+cos(x*x)"`,
  - `"2*sin(x)+cos(2*x)"`.
- Кнопка «Цвет» — открывает диалог `JColorChooser` для выбора цвета линии.
- Кнопка «Обновить» — просто вызывает `repaint()` у панели.
- Центральная панель `Plot` — наследник `JPanel`, умеет рисовать график.

**Как рисуется график:**
- В `paintComponent(Graphics g)` панели `Plot`:
  - читаются границы `a` и `b` через вспомогательный метод `parse(...)` (если введено что‑то не число, берётся значение по умолчанию);
  - по текущему выбранному элементу в `fnBox` выбирается нужная функция (через `DoubleUnaryOperator` и метод `pick(...)`);
  - рисуется рамка (светло‑серая прямоугольная область);
  - берётся, например, 200 точек по X от `a` до `b`:
    - для каждой вычисляется `y = fn.applyAsDouble(x)`;
    - значения X и Y линейно переводятся в пиксели: `toX(...)`, `toY(...)`;
    - соседние точки соединяются линиями.
- Значения Y перед переводом в экран ограничиваются в диапазоне [-1; 1], чтобы график не уходил слишком далеко.

**Почему так:**
- Вместо отдельного класса функции просто используется лямбда/ссылка на метод (`DoubleUnaryOperator`), так меньше кода.
- Цвет хранится в переменной `color`, при смене цвета и нажатии «Обновить» просто вызывается `repaint()`.

---

## Задания 5 и 6 — свои компоненты: панель с тремя метками и игральная кость

**Файл:** `CustomComponents.java`

Содержит три публичных класса *внутри* одного файла:

### Компонент 1: `ThreeLabelPanel`

- Наследуется от `JPanel`.
- Внутри три `JLabel`:
  - верхняя (`top`) — шрифт маленький, Bold+Italic, выравнивание по левому краю;
  - средняя (`center`) — шрифт крупнее, Bold, выравнивание по центру;
  - нижняя (`bottom`) — шрифт маленький, выравнивание вправо.
- В конструкторе задаётся `BorderLayout` и добавление меток по `NORTH`, `CENTER`, `SOUTH`.
- Дополнительные методы:
  - `setPanelBackground(Color c)` — задаёт фон панели и меток (делает их непрозрачными и ставит цвет фона);
  - `setUpperText`, `setCenterText`, `setDownText` — позволяют менять текст каждой метки.

Идея: собрать часто используемую конструкцию из трёх меток в один компонент, который можно переиспользовать.

### Компонент 2: `SimpleDie` — «игральная кость»

- Наследуется от `JComponent`.
- Хранит:
  - `int value` — значение 1..6;
  - `boolean active` — реагирует ли на клики;
  - `Color pip` и `Color face` — цвет точек и фона;
  - `Random rnd` — генератор случайных чисел.
- В конструкторе:
  - `setPreferredSize(80,80)` — примерно квадратная кость;
  - вешается `MouseListener` — при клике, если `active == true`, вызывается `roll()`.
- Методы управления:
  - `roll()` — выбирает случайное значение от 1 до 6 и вызывает `repaint()`;
  - `setValue(int v)` — ручная установка значения (с проверкой диапазона);
  - `getValue()`, `setPipColor`, `setFaceColor`, `setActive`, `isActive` — обычные геттеры/сеттеры.
- Рисование (`paintComponent(Graphics g)`):
  - вычисляется квадрат, вписанный в доступный размер;
  - рисуется закруглённый прямоугольник фона (`face`) и чёрная рамка;
  - затем по маске 3×3 (булевый массив) рисуются точки:
    - для каждого значения от 1 до 6 задан шаблон `true/false`, где надо рисовать кружок;
    - точки выводятся через `fillOval`.

По смыслу это полноценный пользовательский компонент, который можно использовать в других задачах (как в задании 8).

### Демонстрация: `CustomComponentsDemo`

- Наследуется от `JFrame`.
- В конструкторе:
  - создаётся `ThreeLabelPanel`, задаётся мягкий фон и строки «Upper/Center/Lower»;
  - создаётся `SimpleDie`;
  - кнопка `toggle`: по нажатию переключает `active` у кости и текст на кнопке («Отключить» / «Включить»).
- Панель с метками добавляется сверху, кость в центр, кнопка снизу.

Это маленькое окно для проверки и демонстрации своих компонентов.

---

## Задание 8 — простая игра на двоих с кубиком

**Файл:** `Task8SimpleGame.java`

**Игровые данные:**
- `int[] board` — массив очков/эффектов по клеткам поля:
  - положительные и отрицательные значения (прибавить/отнять очки);
  - последняя клетка — финиш.
- `boolean[] repeat` — если `true` на клетке, игрок ходит ещё раз.
- `boolean[] loseAll` — если `true`, все очки игрока обнуляются.

**Состояние игры:**
- две кости `CustomComponents.SimpleDie` — по одной на игрока (`d1`, `d2`);
- два счётчика положения (`p1`, `p2`) и очков (`sc1`, `sc2`);
- `int turn` — чей ход (1 или 2);
- `boolean done` — игра закончена или нет;
- две метки `s1`, `s2` — показывают состояние игроков;
- `JTextArea log` — журнал ходов.

**Интерфейс:**
- Верхняя панель (`GridLayout(2,1)`) с двумя `JLabel` для состояния игроков.
- Центр — `JScrollPane` с `JTextArea` (логи).
- Низ (`GridLayout(2,2)`):
  - слева две кости;
  - справа две кнопки: «Бросить» и «Сброс».

**Логика хода:**
- При нажатии «Бросить»:
  - если `done == true`, просто пишется в лог «Игра завершена.»;
  - иначе берётся кость текущего игрока (`turn == 1 ? d1 : d2`), вызывается `roll()`, читается `value`;
  - позиция игрока увеличивается на `value`, но не больше последней клетки;
  - вызывается `apply(player)`:
    - по текущей клетке берётся `delta = board[pos]`;
    - если `loseAll[pos] == true`, соответствующий счётчик очков обнуляется и логируется сообщение;
    - если `delta != 0`, очки увеличиваются или уменьшаются, пишется в лог;
    - если позиция — финиш, игроку добавляется +50 очков, `done = true`, и вызывается `announce()`.
  - вызывается `updateLabels()` — обновление текстов меток `s1`, `s2`.
  - если игра ещё не окончена:
    - проверяется `repeat[pos]` для текущего игрока:
      - если `true` — в лог пишется, что игрок ходит ещё раз;
      - если `false` — `turn = 3 - turn;` (переключение 1 ⇄ 2).

**Сброс:**
- Кнопка «Сброс» вызывает `reset()`:
  - обнуляются позиции и очки;
  - ход снова за игроком 1;
  - `done = false`;
  - очищается поле логов и добавляется строка «Новая игра. Начинает игрок 1.»;
  - обновляются метки.

По сути это настольная игра «клеточное поле + кубик», реализованная максимально простыми средствами.

---

## Как запускать

Из каталога `sem3/Java`:

```bash
javac lab7/*.java
java lab7.Task1LookAndFeel
java lab7.Task2ControlPad
java lab7.Task3BallController
java lab7.Task4FunctionPlotter
java lab7.CustomComponents$CustomComponentsDemo
java lab7.Task8SimpleGame
```

Все классы содержат `public static void main(String[] args)`, который запускает соответствующее окно.

---

## Как это объяснять через Python

- `JFrame` ≈ главное окно (`Tk` / `QMainWindow`).
- `JPanel`/`JComponent` с `paintComponent` ≈ свой виджет/канвас с методами рисования.
- `javax.swing.Timer` ≈ `after()` в Tkinter — таймер в GUI‑потоке.
- Логика вроде `setLookAndFeel` + `updateComponentTreeUI` — смена темы оформления и принудительное обновление всех виджетов.
- Пользовательские компоненты (`ThreeLabelPanel`, `SimpleDie`) — это как свои классы виджетов в PyQt с переопределённым `paintEvent` и собственными свойствами.

Такой README этого уровня детализации обычно достаточно, чтобы уверенно объяснить преподавателю каждое задание. 
