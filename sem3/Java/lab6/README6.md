# Лабораторная работа 6 — рисование и события в AWT/Swing

В этой лабораторной вы тренируетесь работать с Java/Swing примерно в тех же задачах, которые обычно делают в Python‑GUI (Tkinter / PyQt): рисование на холсте, обработка мыши и клавиатуры, анимация, работа с изображениями.

Каждое задание оформлено как отдельный `*.java`‑файл (или небольшой набор файлов). Ниже — кратко, но достаточно подробно, чтобы объяснить преподавателю «что где и зачем».  
Отталкиваюсь от того, что вы уже умеете программировать на Python.

---

## Задание 1 — график sin(x) на [-π; π]

**Файл:** `Task1SinePlot.java`

- Класс `Task1SinePlot` наследуется от `JFrame` — это главное окно, как `Tk()` в Tkinter.
- В конструкторе:
  - задаётся заголовок окна;
  - создаётся панель `SimpleSinePanel` и добавляется в окно;
  - вызывается `pack()` и установка позиции по центру экрана.
- Внутренний класс `SimpleSinePanel` наследуется от `JPanel` и переопределяет `paintComponent(Graphics g)`:
  - сначала вызывается `super.paintComponent(g)` — это как «очистить холст»;
  - рисуется белый фон и рамка;
  - в цикле по X от `start` до `end` вычисляется `y = Math.sin(x)`;
  - координаты (x, y) масштабируются в пиксельные (по сути линейное преобразование);
  - точки соединяются линиями, получается график.

По смыслу это то же самое, что в Python: класс окна, класс своего `Canvas`, в котором в функции рисования выручивается график.

---

## Задание 2 — класс `Curve` и график sin(x) на [0; 2π]

**Файлы:** `Curve.java`, `Task2CurveDemo.java`

- `Curve` — маленький класс‑обёртка для кривой:
  - хранит массивы `xs` и `ys` (массив точек);
  - метод `setData(Function<Double, Double> f, double start, double end, int samples)` вычисляет значения функции на равномерной сетке;
  - метод `draw(Graphics g, int left, int top, int width, int height)` рисует ломаную по этим точкам.
- `Task2CurveDemo`:
  - создаёт окно с пользовательской панелью;
  - в панели есть объект `Curve`, для которого вызывается `setData(Math::sin, 0, 2*Math.PI, 400)` — то есть готовится график синуса;
  - в `paintComponent` панели вызывается `curve.draw(...)`.

Идея: отделить вычисление точек функции от их рисования. В Python вы могли бы сделать похожий класс и потом передать его в функцию, которая знает, как рисовать на `Canvas`.

---

## Задание 3 — график с осями (Axis / Graph / Curve)

**Файлы:** `Axis.java`, `Graph.java`, `Curve.java`, `Task3GraphDemo.java`

- `Axis` — модель оси (X или Y):
  - хранит минимум и максимум (например, X: 0..2π, Y: −1.5..1.5);
  - умеет перевести значение из «математики» в пиксель по формуле вида `px = left + (value-min)/(max-min) * width`;
  - рисует саму ось и деления.
- `Graph`:
  - хранит две оси (X, Y) и список кривых (`List<Curve>`);
  - в методе `draw` рисует оси и все кривые, используя преобразования осей.
- `Task3GraphDemo`:
  - настраивает оси и одну кривую sin(x);
  - показывает всё в окне.

Это уже чуть больше похоже на «свой маленький matplotlib», но очень примитивный и без лишних классов.

---

## Задание 4 — координаты мыши и смена цвета

**Файл:** `Task4MouseCoordinates.java`

- Главное окно создаёт панель `CoordinatesPanel`.
- В `CoordinatesPanel`:
  - хранится последняя точка клика мышью (`Point point`);
  - хранится текущий цвет (например, `Color color`);
  - через `addMouseListener` обрабатывается клик: `point = e.getPoint(); repaint();`;
  - через `addKeyListener` ловятся символы `r/g/b/...` и меняется цвет.
- В `paintComponent(Graphics g)`:
  - очищается фон;
  - если точка задана — рисуется метка/кружок и текст с координатами в текущем цвете.

С точки зрения Python — это аналог биндов `"<Button-1>"` и `"<Key>"` к функциям, которые меняют состояние и вызывают перерисовку.

---

## Задание 5 — просмотр изображения

**Файл:** `Task5ImageViewer.java`

- При запуске:
  - с помощью `ImageIO.read(...)` загружается файл `sample.jpg` в `BufferedImage`;
  - создаётся панель, в `paintComponent(Graphics g)` которой вызывается `g.drawImage(image, ...)`.
- К окну могут быть привязаны простые элементы (меню/кнопки): открыть другой файл, выйти и т.п., но логика намеренно простая — это «минимальный просмотрщик картинки».

Если вы работали с Pillow в Python, это то же самое: прочитать `Image.open(...)` и вывести его на виджет.

---

## Задание 6 — фильтры для изображения

**Файл:** `Task6ImageFilters.java`

- Основная идея: к уже загруженному `BufferedImage` применяются простые фильтры:
  - перевод в оттенки серого;
  - инверсия цветов;
  - возможно лёгкое изменение яркости/контраста.
- Реализация фильтра:
  - проходим по всем пикселям (двойной цикл по x,y);
  - читаем цвет `int rgb = image.getRGB(x, y)`;
  - выделяем `r, g, b`, пересчитываем (например, `gray = (r+g+b)/3`);
  - собираем новый цвет и записываем обратно `setRGB`.
- Интерфейс: несколько кнопок/элементов управления, по нажатию — выбранный фильтр применяется к копии изображения, и панель перерисовывается.

По сути, это прямой аналог ручной обработки пикселей через Pillow, только API чуть другой.

---

## Задание 7 — «прыгающие шарики»

**Файл:** `Task7BouncingBalls.java`

- Внутри есть панель `BallPanel`:
  - список `List<Ball>` — каждый шарик хранит `x, y, dx, dy, radius`;
  - таймер `new Timer(16, e -> tick())` — 16 мс ≈ 60 кадров в секунду.
- В методе `tick()`:
  - координаты шариков обновляются: `x += dx`, `y += dy`;
  - если шарик выходит за границы панели — скорость по соответствующей оси меняется на противоположную (`dx = -dx` и т.д.), получается отражение от стенки;
  - затем вызывается `repaint()`.
- В `paintComponent(Graphics g)` все шарики рисуются как заполненные окружности.

Аналог в Python: список объектов с состоянием, периодический вызов функции `update()` через `after` и перерисовка холста.

---

## Задание 8 — бегущая строка

**Файл:** `Task8Marquee.java`

- Панель `MarqueePanel`:
  - хранит текст (или список сообщений);
  - хранит текущую X‑координату вывода текста;
  - таймер раз в N миллисекунд уменьшает X, сдвигая текст влево.
- В `paintComponent(Graphics g)`:
  - очищается фон;
  - вызывается `g.drawString(message, x, y)` с текущей X‑координатой;
  - если текст полностью ушёл за левую границу, X сбрасывается вправо, чтобы строка «пошла» ещё раз.

Это минимальная реализация бегущей строки без буферизации и сложных эффектов.

---

## Как запускать

Во всех основных классах есть метод:

```java
public static void main(String[] args) {
    SwingUtilities.invokeLater(() -> new TaskXxx().setVisible(true));
}
```

Запускаете из каталога `sem3/Java`:

```bash
javac lab6/*.java      # компиляция всех задач
java lab6.Task1SinePlot
java lab6.Task2CurveDemo
java lab6.Task3GraphDemo
java lab6.Task4MouseCoordinates
java lab6.Task5ImageViewer
java lab6.Task6ImageFilters
java lab6.Task7BouncingBalls
java lab6.Task8Marquee
```

---

## Сопоставление с Python, чтобы объяснять преподавателю

- `JFrame` — главное окно (примерно как `Tk()` в Tkinter или `QMainWindow` в PyQt).
- Пользовательский `JPanel` с `paintComponent(Graphics g)` — свой виджет/канвас, в котором вы вручную рисуете, как в обработчике `paintEvent` или в функции, привязанной к перерисовке.
- `javax.swing.Timer` — штатный способ анимации в Swing; аналог `root.after(ms, callback)` в Tkinter: периодически вызывает функцию в GUI‑потоке.
- Обработчики событий:
  - мышь: `addMouseListener(...)` и методы `mouseClicked`, `mouseMoved` и т.п.;
  - клавиатура: `addKeyListener(...)` и `keyTyped`, `keyPressed`.
  Это примерно то же, что `widget.bind("<Button-1>", handler)` и `widget.bind("<Key>", handler)` в Tkinter.
- Работа с изображениями:
  - в Java используется `BufferedImage`, пиксели читаются/пишутся через `getRGB`/`setRGB`;
  - логика фильтров такая же, как в Pillow: два цикла и простая математика над `r, g, b`.

Так можно коротко объяснить любую из задач, опираясь на то, что вы уже знаете в Python.
